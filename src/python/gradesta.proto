/*
Copyright (c) 2017 Timothy Hobbs

This file is part of Gradesta.

Gradesta is free software: you can redistribute
it and/or modify it under the terms of the GNU
Affero General Public License as published by
the Free Software Foundation, either version 3
of the License, or (at your option) any later
version.

This program is distributed in the hope that it
will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.  See the GNU Affero General Public
License for more details.

You should have received a copy of the GNU
Affero General Public License along with this
program. If not, see
<http://www.gnu.org/licenses/>.
*/
//Index
// §1 What is a Gradesta graph?
// §2 What is the architecture of the Gradesta
// protocol?
// §3 How does the Gradesta protocol relate to
// RDF?
// §4 What is the difference between Gradesta
// and graph databases such as neo4j?
// §5 Back to the protocol definition
// §6 Starting up
// §7 Getting cells
// §8 Setting cells client side
// §9 Setting cells service side
// §10 Unsubscribing from neighborhoods
// §11 Interacting with cells
// §12 Cursors
// §13 manager.sock REQ container type
// §14 manager.sock REPLY container type
// §15 service.sock REQ container type
// §16 service.sock REPLY container type
// §17 Transactions and other goodies
// §18 Closing remarks

//   *************************************   //
//       §1 What is a Gradesta graph?
//   *************************************   //
//
// This protocol is designed to allow you to
// easilly create services who's user inteface
// is expressed as an interactive directed
// graph.
//
// The name Gradesta stands for graph of
// stacks.
//
// The basic principle is that a Gradesta graph
// is a collection of cells, each with up to
// three links to other cells.
// One of those links is the "next in stack
// link",
// One is the "previous in stack link".
// the third is the "edge link".
// 
// The stack links allow you to build a doubly 
// linked list of cells. You can only stack
// link to an cell which has not been stack
// linked previously. And the next and previous
// stack links must match up to create a linear
// structure.
//
// The edge link can link to any cell
// including itself.
//
// This is a stack:
//
// ┌────┐
// │Foo │
// │Bar │
// │Baz │
// └────┘
//
// Foo next-links to Bar.
// Bar prev-links to Foo.
// Bar next-links to Baz.
// Baz prev-links to Bar.
//
//  Each cell may also have an edge link.
// 
// ┌────┐    ┌────┐
// │Foo │───▸│Lol │
// │Bar │    └────┘
// │Baz │
// └────┘
//
// Here, Foo has an edge link to Lol.
// Each cell can only have one edge link.
// comming out of it, but it can have multiple
// incomming edge links.
//
// ┌────┐    ┌────┐
// │Foo │──┬▸│Lol │
// │Bar │──┘ └────┘
// │Baz │
// └────┘
//
// Here, both Foo and Bar, have edge links
// to Lol.
//
// It is possible for an cell to edge link
// to itself.
//
//   ┌────┐
//   │Foo │
//   │Bar │
// ┌▸│Baz │─┐
// │ └────┘ │
// └────────┘
//
// Here, Baz links to itself.
//
// Other types of loops are also allowed:
//
// ┌──────────────────┐ 
// │ ┌────┐    ┌────┐ │
// └▸│Foo │──┬▸│Lol │─┘
//   │Bar │──┘ └────┘
//   │Baz │
//   └────┘
//
// There is no maximum size limit for Gradesta
// graphs, and a procedurally generated
// Gradesta graph often is infinite in size.
//
// It is possible to have an infinite number of
// cells, and even the stacks can be loaded
// lazily so as to allow for infinite stacks.
//
// Cells are composed of three parts:
//
//  1) A string called "type", which roughly
//  correlates to a MIME type.
//
//  2) A string called "text", which should be
//  the human readable contents of the cell.
//
//  3) A collection of resources, which can be
//  identified by their "path" strings. These
//  resources each have an array of bytes
//  called "data". Resources are used for
//  storing non text-data in Gradesta. For
//  example, if the cell's type is
//  "text/markdown" and the cell's text is a
//  markdown document containing an image. Then
//  the cell may have a resource associated
//  with it which contains the image's path and
//  data.
message   Cell                               {
          Identifier  id                 = 1;
          string      text               = 2;
          string      type               = 3;
          Identifier  destination        = 4;
          Identifier  next               = 5;
          Identifier  prev               = 6; }

message   Resource                            {
          Identifier  cell               = 1;
          string      path               = 2;
          bytes       data               = 3; }

message   Identifier                          {
          string      id                 = 1;
          string      path               = 2; }
//
// There are no edge labels.
// There is also no concept of a port.
// Both of these concepts can be emulated,
// however.
//
// ┌─────────────┐
// │vertex_label │    ┌───────────────┐
// │edge_label   │───▸│another_vertex │
// └─────────────┘    └───────────────┘
//
// You can imagine the first cell in the
// stack as being the vertex label, and the
// second cell as being the edge label.
//
// You can also designate a region of the stack
// to act as a collection of incomming ports.
//
// ┌─────────────┐    ┌───────────────┐
// │vertex_label │    │another_vertex │
// │edge_label   │───▸│in_port        │
// └─────────────┘    └───────────────┘
//
// You can also combine both concepts.
//
//   ┌────────────┐    ┌───────────┐
//   │vertex_1    │    │vertex_2   │
// ┌▸│in_port_1   │  ┌▸│in_port    │
// │ │in_port_2   │  │ │edge_label │─┐
// │ │edge_label  │──┘ └───────────┘ │
// │ └────────────┘                  │
// └─────────────────────────────────┘
//
// In the above example, vertex_1 has
// an edge which links to vertex_2's first in
// port. And vertex_2 has an edge which links
// to vertex_1's in_port_1.
// vertex_1's in_port_2 is unconnected.
//
// ***************************************   //
// §2 What is the architecture of the Gradesta
// protocol?
// ***************************************   //
//
// Gradesta uses a client service architecture
// in which clients can be user interfaces
// which allow the user to interact with the
// graph or a automated scripts. The protocol
// allows the service to accept or reject
// interactions, and therefore, it is 
// easy for the service to create new rules
// about which graphs are acceptable and which
// ones are not. For example, if you wanted to
// add the rule that an in_port could only be
// connected to once, you could do so, by
// rejecting all changes to the graph which
// violated that rule. Through clever service
// construction, one can interact with almost
// any kind of graph like user interface or
// document.
//
// The protocol is designed with the goal of
// making it as easy as possible to create new
// services which provide interactive graphs.
// This at the expense of making it harder to
// develop clients for interacting with those
// graphs.
//
// However, creating clients is not complex
// either.
//
// The protocol is intended for use on the
// local system via unix sockets and the
// ZeroMQ message passing system.
//
// Future, network based, aditions to this
// architecture are envisioned, but not yet
// precisely planned.
//
// Each graph service launches as a normal
// *nix process. It then creates a directory
// in $GRADESTA_SERVICE_DIR if that env_var is
// set, otherwise it defaults to:
// $HOME/Gradesta/
// The directory is of the format
// $GRADESTA_SERVICE_DIR/<service-name>/internal-path/
//
// As an example, the "foo" service might
// create a socket at
// $HOME/Gradesta/foo/bar/service.sock
// This is a ØMQ request/reply socket.
//
// Once service.sock has been created, the
// service launches a "manager" which does
// the heavy lifting of interacting with
// clients and performing resource tracking.
// The manager is launched by calling the
// executable 'gradesta-manager' and passing
// the path $HOME/Gradesta/foo/bar/ as the only
// argument.
//
// The gradesta-manager then creates its own
// socket:
// $HOME/Gradesta/foo/bar/manager.sock
// This is also a ØMQ request/reply socket.
//
// The manager socket acts as a go between
// between the clients and the service.
// The service, rather than having to keep
// track of "n" clients, typically only has
// to keep track of one manager.
//
// When a client wants to connect to a service
// it first connects to manager.sock and
// requests a unique id.
// It then creates two sockets at.
// $HOME/Gradesta/foo/bar/clients/<id>/update.sock
// and
// $HOME/Gradesta/foo/bar/clients/<id>/cursor.sock
//
// update.sock is a pub/sub socket to which the
// client is the subscriber and to which the
// manager publishes relevant changes which
// are made to the graph. This won't be all
// changes, but rather, only changes that are
// in view on the client side. The manager
// tracks what is in view internally.
//
// cursor.sock is a pub/sub socket to which the
// client is the publisher. It publishes the
// currently selected vertext in the graph.
// Any process on the system can now subscribe
// to this socket and stay in sync with the
// client's view.
// 
// ***************************************   //
// §3 How does the Gradesta protocol relate to
// RDF?
// ***************************************   //
//
// RDF is a format for describing graphs. These
// graphs are very simple and textual, just
// like Gradesta graphs. However, the goals are
// quite different. RDF's goal is to collect
// facts into a "logic database" and to be able
// to answer questions about data in a user
// friendly manner. It also tries to allow the
// computer to create data visualizations. In
// many ways, RDF is like prolog for people who
// like comitees. It is standardized by the
// W3C.
//
// The Gradesta protocol could be used to serve
// RDF graphs, and indeed that would be a good
// fit. Both ecosystems are text centric and
// intended to present their data to users as
// well as allow users to edit and enter new
// data.
//
// However, Gradesta applications are broader
// in scope than RDF. You can create a visual
// programming language that uses Gradesta as
// its front end, or a mind mapping program, or
// a menu based email client, or a menu based
// wiki, or a menu based CAD program ect.
//
// ***************************************   //
// §4 What is the difference between Gradesta
// and graph databases such as neo4j?
// ***************************************   //
// 
// Like RDF, graph databases focus on their
// ability to algorithmically answer
// questions/queries about data. Unlike RDF,
// however, graph databases go beyond basic
// textual fact like data. Any kind of data can
// be stored in a graph database. This makes it
// less likely that the Gradesta would be
// connected to an enterprise graph database.
// Gradesta clients may not have the capability
// to display and edit the richer data-sets
// which are stored in graph databases.
// Therefore, it is more likely that graph
// databases will require their own custom
// front ends to access and enter data to
// access and enter data.
//
//   *************************************   //
//    §5 Back to the protocol definition
//   *************************************   //
// -------------------------------
//
syntax         =          "proto3"            ;
package                    tg                 ;

//   *************************************   //
//              §6 Starting up               //
//   *************************************   //
// When a service starts up it launches
// gradesta-manager. This does not require any
// ØMQ/protobuf communication. However, when a
// client starts up, it will request from the
// manager a unique ID.
// 
// ┌────────────────┬────────────┬────────────┐
// │ Service        │ Manager    │ Client     │
// ├────────────────┼────────────┼────────────┤
// │Starts up       │            │            │
// │launches manager│            │            │
// ├────────────────┼────────────┼────────────┤
// │                │starts up   │            │
// │                │creates     │            │
// │                │manager.sock│            │
// ├────────────────┼────────────┼────────────┤
// │                │            │← REQ via   │
// │                │            │manager.sock│
// │                │            │RequestId   │
// ├────────────────┼────────────┼────────────┤
// │                │ REPLY via →│            │
// │                │manager.sock│            │
// │                │ReplyId     │            │
// ├────────────────┼────────────┼────────────┤
// │                │            │creates     │
// │                │            │sockets:    │
// │                │            │update.sock │
// │                │            │cursor.sock │
// └────────────────┴────────────┴────────────┘
//
// Note that the service doesn't actually have
// any work to do when it comes to registering
// new clients. That is handled by the manager
// in full.
//
message   RequestId                           {
          string        prefix           = 1; }

message   ReplyId                             {
          string        client_id        = 1; }

//   *************************************   //
//            §7 Getting cells               //
//   *************************************   //
// A client can request a Neighborhood of cells
// by contacting the manager via manager.sock.
// A neighborhood is a region of a graph which
// is bounded by maximum upstream, downstream,
// and stack distances from a given cell.
//
// The manager forwards the requested
// neighborhood to the service which then
// returns all cells which fall within it's
// bounds.
//
// The manager records which neighborhoods have
// been requested by which clients, and, upon
// receiving updates from the service, only
// forwards those changes to the clients for
// whom the changes are relevant. For this
// reason, the NeighborhoodSubscription request
// contains the client's ID.
//
// Resources that bellong to cells are
// forwarded after the fact in order to reduce
// round trip time for delivering the actual
// cells.
//
// ┌─────────────┬────────────┬───────────────┐
// │ Service     │ Manager    │ Client        │
// ├─────────────┼────────────┼───────────────┤
// │             │            │← REQ via      │
// │             │            │manager.sock   │
// │             │   NeighborhoodSubscription │
// │             │            │(subscribe)    │
// ├─────────────┼────────────┼───────────────┤
// │             │ ← REQ via  │               │
// │             │service.sock│               │
// │             │Neighborhood│               │
// ├─────────────┼────────────┼───────────────┤
// │REPLY via →  │            │               │
// │service.sock │            │               │
// │RequestedNeighborhood     │               │
// ├─────────────┼────────────┼───────────────┤
// │             │ REPLY via →│               │
// │             │manager.sock│               │
// │             │RequestedNeighborhood       │
// ├─────────────┼────────────┼───────────────┤
// │REQ via    → │            │               │
// │manager.sock │            │               │
// │             │            │               │
// ├─────────────┼────────────┼───────────────┤
// │             │ PUB   via →│               │
// │             │update.sock │               │
// │             │Resource    │               │
// ├─────────────┼────────────┼───────────────┤
// │             │← REPLY via │               │
// │             │manager.sock│               │
// │             │NULL        │               │
// └─────────────┴────────────┴───────────────┘
message   Neighborhood                        {
          Identifier    id               = 1;
          int64         upstream         = 2;
          int64         downstrea        = 3;
          int64         stack            = 4; }

message   NeighborhoodSubscription            {
          string        client_id        = 1;
          Neighborhood  neighborhood     = 2; }

message   RequestedNeighborhood               {
          bool          ok               = 1;
          string        error            = 2;
repeated  Cell          cells            = 3; }
//   *************************************   //
//         §8 Setting cells client side      //
//   *************************************   //
//
// The client can set the text values and the
// links of cells and resources by contacting
// the manager. Multiple cells and resources
// can be set at the same time.
//
// The manager will automatically notify
// clients to whom the changes are relevant.
//
// ┌─────────────┬────────────┬───────────────┐
// │ Service     │ Manager    │ Client        │
// ├─────────────┼────────────┼───────────────┤
// │             │            │← REQ via      │
// │             │            │manager.sock   │
// │             │            │Set            │
// ├─────────────┼────────────┼───────────────┤
// │             │ ← REQ via  │               │
// │             │service.sock│               │
// │             │Set         │               │
// ├─────────────┼────────────┼───────────────┤
// │REPLY via →  │            │               │
// │service.sock │            │               │
// │SetOutcome   │            │               │
// ├─────────────┼────────────┼───────────────┤
// │             │ REPLY via →│               │
// │             │manager.sock│               │
// │             │SetOutcome  │               │
// ├─────────────┼────────────┼───────────────┤
// │             │ PUB   via →│               │
// │             │update.sock │               │
// │             │Set         │               │
// └─────────────┴────────────┴───────────────┘
message   Set                                 {
repeated  Cell          cells            = 1;
repeated  Resource      resources        = 2; }

message   SetOutcome                          {
          bool          ok               = 1;
          string        error            = 2;
repeated  Cell          cells            = 3;
repeated  Resource      resources        = 4; }
//   *************************************   //
//     §9 Setting cells service side         //
//   *************************************   //
//
// Service side, cells can also be set and
// their changes propogated to clients
// automatically, by the manager.
//
// ┌─────────────┬────────────┬───────────────┐
// │ Service     │ Manager    │ Client        │
// ├─────────────┼────────────┼───────────────┤
// │REQ   via →  │            │               │
// │manager.sock │            │               │
// │Set          │            │               │
// ├─────────────┼────────────┼───────────────┤
// │             │ PUB   via →│               │
r/ │             │update.sock │               │
// │             │Set         │               │
// ├─────────────┼────────────┼───────────────┤
// │             │← REPLY via │               │
// │             │manager.sock│               │
// │             │NULL        │               │
// └─────────────┴────────────┴───────────────┘
//
//   *************************************   //
//    §10 Unsubscribing from neighborhoods   //
//   *************************************   //
//
// When a client no longer wishes to be
// subscribed to all changes that happen to a
// given neighborhood of cells, it can
// unsubscribe by sending the
// UnsubscribeNeighborhood command to the
// manager.
//
// ┌─────────────┬────────────┬───────────────┐
// │ Service     │ Manager    │ Client        │
// ├─────────────┼────────────┼───────────────┤
// │             │            │← REQ via      │
// │             │            │manager.sock   │
// │             │    NeighborhoodSubscription│
// │             │            │(unsubscribe)  │
// ├─────────────┼────────────┼───────────────┤
// │             │ REPLY via →│               │
// │             │manager.sock│               │
// │             │NULL        │               │
// └─────────────┴────────────┴───────────────┘
//
message   NeighborhoodSubscription            {
          string        client_id        = 1;
          Neighborhood  neighborhood     = 2; }

//   *************************************   //
//     §11 Interacting with cells            //
//   *************************************   //
//
// Cells can have events associated with them
// which are sent from the client. These events
// are defined in the definition of the cell's
// type. For example, "text/plain" cells have
// "clicked 1", "clicked 2" and "clicked 3"
// events. The service can either ignore an
// event or respond to it however it likes.
//
// There is a data feild associated with events
// which in most cases will be empty, but
// form-like cell types may have submition
// events which would take advantage of this
// data feild.
//
// ┌─────────────┬────────────┬───────────────┐
// │ Service     │ Manager    │ Client        │
// ├─────────────┼────────────┼───────────────┤
// │             │            │← REQ via      │
// │             │            │manager.sock   │
// │             │            │Event          │
// ├─────────────┼────────────┼───────────────┤
// │             │ ← REQ via  │               │
// │             │service.sock│               │
// │             │Event       │               │
// ├─────────────┼────────────┼───────────────┤
// │REPLY via →  │            │               │
// │service.sock │            │               │
// │SetOutcome   │            │               │
// ├─────────────┼────────────┼───────────────┤
// │             │ REPLY via →│               │
// │             │manager.sock│               │
// │             │SetOutcome  │               │
// ├─────────────┼────────────┼───────────────┤
// │             │ PUB   via →│               │
// │             │update.sock │               │
// │             │Set         │               │
// └─────────────┴────────────┴───────────────┘
//
// As you can see, triggering an event is very
// much the same pattern as setting the value
// of a cell or resource. The event is
// triggered and any resulting changes in the
// graph are propagated back to the clients.
//
message   Event                               {
          Identifier  cell                = 1;
          int64       type                = 2;
          bytes       data                = 3;}

//   *************************************   //
//     §12 Cursors                           //
//   *************************************   //
//
// Clients publish which cell is currently
// focused. This can be usefull for keepting
// two clients view in sync. It is also very
// useful to be able to have a step through
// debugger which publishes where it is at, and
// then have your graph editor follow the
// debugger so that you can see where you are
// in the code.
//
// A client may follow another client.
// ┌─────────────┬────────────┬───────────────┐
// │ Service     │ Manager    │ Client        │
// ├─────────────┼────────────┼───────────────┤
// │             │            │↓ SUB via      │
// │             │            │cursor.sock    │
// │             │            │Cursor         │
// └─────────────┴────────────┴───────────────┘
//
// Or the service could follow a client.
// ┌─────────────┬────────────┬───────────────┐
// │ Service     │ Manager    │ Client        │
// ├─────────────┼────────────┼───────────────┤
// │↓ SUB via    │            │               │
// │cursor.sock  │            │               │
// │Cursor       │            │               │
// └─────────────┴────────────┴───────────────┘
message   Cursor                              {
          Identifier  cell                = 1;
          string      new_type            = 2;
repeated  int64       field               = 3;}

//   *************************************   //
//    §13 manager.sock REQ container type    //
//   *************************************   //
message   RequestToManager                    {
repeated  RequestId   request_id         = 1;
repeated  NeighborhoodSubscription subscribe
                                         = 2;
repeated  NeighborhoodSubscription unsubscribe
                                         = 3;
repeated  Set         set                = 4;
repeated  Set         set_service_side   = 5;
repeated  Event       event              = 6; }

//   *************************************   //
//   §14 manager.sock REPLY container type   //
//   *************************************   //
message   ReplyFromManager                    {
repeated  ReplyId     reply_id           = 1;
repeated  RequestedNeighborhood
                 requested_neighborhood  = 2;
repeated  SetOutcome  set_outcome        = 3; }

//   *************************************   //
//    §15 service.sock REQ container type    //
//   *************************************   //
message   RequestToService                    {
repeated  Neighborhood get_neighborhood  = 1;
repeated  Set         set                = 2;
repeated  Event       event              = 3; }

//   *************************************   //
//   §16 service.sock REPLY container type   //
//   *************************************   //
message   ReplyFromService                    {
repeated  RequestedNeighborhood
                 requested_neighborhood  = 1;
repeated  SetOutcome  set_outcome        = 2; }

//   *************************************   //
//   §17 Transactions and other goodies      //
//   *************************************   //
// You may have noticed that right now, the
// manager is managing subscriptions and
// routing changes to the clients that need
// them. The astute reader will have wondered
// whether this actually makes sense. Afterall,
// the client can figure out what it needs and
// ignore messages that are irrelevant to it.
// You may even wonder whether the middle man
// manager is making performance better or
// worse through this routing. The answer is,
// that it is probably making it worse.
//
// The reason for the manager is not
// performance but rather simplicity and future
// proofing. If the protocol was developed
// without a manager from the get go, it would
// be impossible to implement transactions
// later on, and transactionality may become a
// necessary feature in the future.
//
// 
//   *************************************   //
//             §18 Closing remarks           //
//   *************************************   //
//
//   Have fun! Go VEGAN! And fuck capitalism!
//
// Many people, upon hearing the phrase, "fuck
// capitalism" think of communism. Soviet
// Communism to be precice. But in communist
// Russia they still used money, and if you're
// trying to fuck capitalism, and you're still
// using money, than you're not doing it right.
//
// You fuck capitalism by buying less shit
// you don't need. By making things yourself.
// By growing your own food. By making/doing
// things for others for free. By cooperating
// with others to do things in a mutually
// beneficial fashion without the use of money.
// By squating abandoned buildings, by eating
// from the dumptser.
//
// My vision for a new society:
//
// Within capitalism, it is very hard to trust
// people. You never know if someone is being
// honest, or if they are trying to sell you
// something. True friendship exists only in a
// non-comercial context and the best things
// in life are anarchy already.
//
// If a few people fuck capitalism, then they
// can be friends, real friends, true friends.
// And they can enjoy eachothers company and
// make some free stuff that everyone can
// enjoy. That's a good thing.
//
// If more people fuck capitalism, then that's
// even better.
//
// And if everyone fucks capitalism, then we
// can all walk around in toe shoes playing
// frisbee on abandoned superhighways, eating
// free VEGAN pizza baked by the fully
// automated GNU Pizamaker, and we can smile at
// eachother in the sunshine, knowing that
// we're all friends and no one's trying to
// sell shit or take over.
//
// IT ALWAYS MAKES SENSE TO FUCK CAPITALISM!
