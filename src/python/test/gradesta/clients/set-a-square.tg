[0, "#!/usr/bin/python3\n# This is a test client which asks for a bunch of client IDs", [["^#", 1], ["", 2], ["", 49], ["", 78], ["!^pycfg", 4]]]
[1, "License: AGPL >= 3\nCopyright (c) 2017 Timothy Hobbs\n\nThis file is part of Gradesta.\n\nGradesta is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as\npublished by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program. If not, see <http://www.gnu.org/licenses/>.", []]
[2, "#imports\nimport sys\nimport argparse\nimport os\nimport zmq\nimport gradesta_pb2\nimport datetime\nimport time", []]
[32, "bind_sockets args |\nzmq_context = zmq.Context()\nsock = zmq_context.socket(zmq.REQ)\npath = \"ipc://\"+os.path.join(os.getcwd(),\"manager.gradesock\")\nprint(path)\nsock.connect(path)", [["; sock | \"this-client\"", 123]]]
[4, "parse_cli_args\nparser = argparse.ArgumentParser(description=\"\"\"ask-for-ids asks for client ids from the manager\"\"\",formatter_class=argparse.RawTextHelpFormatter)\nargs = parser.parse_args()", [["; args|", 127]]]
[128, "cache_cell cells | rfm c\ncells[c.id] = c", [["; cells |", 121]]]
[129, "set_failed rfm c\nprint(\"Set failed \"+rfm.set_outcome.error)", []]
[78, "#classes", [["", 126]]]
[49, "#functions", []]
[121, "done\nprint(\"Done.\")", []]
[123, "ask_for_id sock | idp\nreq = gradesta_pb2.RequestToManager()\nidreq = gradesta_pb2.RequestId()\nidreq.prefix = idp\nreq.request_id.extend([idreq])\nreqb = req.SerializeToString()\nprint(\"Sending request to manager. Id prefix = %s\"%idp)\nsock.send(reqb)\nrfm = gradesta_pb2.ReplyFromManager()\nprint(\"Waiting for reply from manager.\")\nrfm.ParseFromString(sock.recv())\nfor id in rfm.assigned_id:\n print(id.client_id)\n client_id = id.client_id", [["; sock client_id |", 125]]]
[125, "set_cell sock client_id |\nrqm = gradesta_pb2.RequestToManager()\ns = rqm.set\nc = gradesta_pb2.Cell()\ndt = datetime.datetime.now(LocalTZ())\nc.id = client_id + \"-\" + dt.isoformat()\nc.text = \"foo\"\nc.type = \"text/plain\"\nc.generation = 0\nc.tags = \"\"\nc.editable = True\ns.cells.extend([c])\nsock.send(rqm.SerializeToString())\nrfm = gradesta_pb2.ReplyFromManager()\nrfm.ParseFromString(sock.recv())", [["rfm.set_outcome.ok ; sock client_id | rfm c", 128], ["not rfm.set_outcome.ok ; sock client_id | rfm c", 129]]]
[126, "class LocalTZ(datetime.tzinfo):\n# https://stackoverflow.com/questions/2720319/python-figure-out-local-timezone\n _unixEpochOrdinal = datetime.datetime.utcfromtimestamp(0).toordinal()\n def dst(self, dt):\n  return datetime.timedelta(0)\n def utcoffset(self, dt):\n  t = (dt.toordinal() - self._unixEpochOrdinal)*86400 + dt.hour*3600 + dt.minute*60 + dt.second + time.timezone\n  utc = datetime.datetime(*time.gmtime(t)[:6])\n  local = datetime.datetime(*time.localtime(t)[:6])\n  return local - utc", []]
[127, "init_state\ncells = {}", [["; cells |", 32]]]
