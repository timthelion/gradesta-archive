[0, "#!/usr/bin/python3\n# The gradesta-manager is the universal middle man of the gradesta protocol.\n# It tracks gradesta clients and which cells they are subscribed to.", [["^#", 1], ["", 2], ["", 195], ["", 49], ["", 78], ["!^pycfg", 4]]]
[1, "License: AGPL >= 3\nCopyright (c) 2017 Timothy Hobbs\n\nThis file is part of Gradesta.\n\nGradesta is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as\npublished by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program. If not, see <http://www.gnu.org/licenses/>.", []]
[2, "#imports\nimport sys\nimport optparse\nimport os\nimport zmq\nimport select\nimport gradesta_pb2\nimport subprocess\nimport fcntl\nimport posix", []]
[4, "parse_cli_args\nparser = optparse.OptionParser(usage=\"gradesta-manager SERVICE_PID\",description=\"\"\"the universal middle man of the gradesta protocol.\"\"\")\n\noptions,args = parser.parse_args()\nservice_pid = int(args[0])", [[";args| service_pid", 186]]]
[49, "#functions", [["", 119], ["", 121]]]
[78, "#classes", [["", 261], ["", 223], ["", 237], ["", 141], ["", 217], ["", 269], ["", 146], ["", 154], ["", 79], ["#", 187], ["", 248], ["", 200]]]
[79, "class Subscriptions():", [["^\\t", 80], ["^\\t", 81]]]
[80, "# methods", [["", 82], ["", 102], ["", 84], ["", 100], ["", 104], ["", 107]]]
[81, "# properties", []]
[82, "def __init__(self,center_cell):", [["^\\t", 83]]]
[83, "self._subscriptions = {}\nself.center_cell = center_cell\nself.prev_max = gradesta_pb2.Neighborhood()\nself.n = gradesta_pb2.Neighborhood()", []]
[84, "def _add_subscription(self, subscription):", [["^\\t", 85]]]
[85, "sn = subscription.neighborhood\nn  = self.n\nn.directions = n.directions | sn.directions\nn.max_distance = max(n.max_distance, sn.max_distance)\nn.center_stack = max(n.center_stack, sn.center_stack)\nn.total_max_size = max(n.total_max_size,sn.total_max_size)", []]
[100, "def remove_subscription(self, subscription):", [["^\\t", 101]]]
[101, "self._start()\nn = self.n\nn.max_distance = 0\nn.directions = 0\nn.center_stack = 0\nn.total_max_size = 0\nfor subscription in self._subscriptions.values():\n self._add_subscripion(subscription)\nreturn self._changed()", []]
[102, "def add_cursor(self, cursor):", [["^\\t", 103]]]
[103, "self._start()\nself.subscriptions[subscription.n.cient_id] = subscription\nself._add_subscription(subscription)\nreturn self._changed()", []]
[104, "def _start(self):", [["^\\t", 105]]]
[105, "n = self.n\nself.prev_max.max_distance = n.max_distance\nself.prev_max.directions = n.directions\nself.prev_max.center_stack = n.center_stack\nself.prev_max.total_max_size = n.total_max_size", []]
[107, "def _changed(self):", [["^\\t", 108]]]
[108, "n = self.n\npm = self.prev_max\nreturn not (pm.max_distance == n.max_distance and pm.directions == n.directions and pm.center_stack == n.center_stack and pm.total_max_size == n.total_max_size)", []]
[119, "def walk_edge_of_neighborhood(cells, subscription):", [["^\\t", 120]]]
[120, "NORTH  = 0b0001\nEAST   = 0b0010\nSOUTH  = 0b0100\nWEST   = 0b1000\n\nALL_DIRECTIONS = 0b1111\nALL_BUT_NORTH  = NORTH | ALL_DIRECTIONS\nALL_BUT_EAST   = EAST  | ALL_DIRECTIONS\nALL_BUT_SOUTH  = SOUTH | ALL_DIRECTIONS\nALL_BUT_WEST   = WEST  | ALL_DIRECTIONS\n\nnew_edge = []\ndef take_one_step(new_center, new_directions):\n further_out = copy.deep_copy(subscription)\n further_out.neighborhood = new_center\n further_out.max_distance -= 1\n further_out.directions = new_directions\n new_edge.append(futher_out)\n\ndef is_local(edge):\n return edge.protocol == '.' and edge.path == '.'\n\ncenter = cells[subscription.neighborhood.center_cell]\nif subscription.max_distance > 0:\n if subscription.directions & NORTH:\n  take_one_step(center.stack_prev, ALL_BUT_NORTH)\n if subscription.directions & EAST and is_local(center.eastedge):\n  take_one_step(center.eastedge.client_id, ALL_BUT_EAST)\n if subscription.directions & SOUTH:\n  take_one_step(center.stack_next, ALL_BUT_SOUTH)\n if subscripiton.directions & WEST and is_local(center.westedge):\n  take_one_step(center.westedge.client_id, ALL_BUT_WEST)\n\nreturn new_edge", []]
[121, "def walk_up_and_down_stack(cells, subscription):", [["^\\t", 122]]]
[122, "owned_cells  = set()\nstack_height = subscription.neighborhood.center_stack\ncenter_cell  = cells[subscription.neighborhood.center_cell]\nup   = cells.get(center_cell.stack_prev)\ndown = cells.get(center_cell.stack_next)\nwhile stack_height and (up or down):\n stack_height -= 1\n if up:\n  owned_cells.add(up)\n  up   = cells.get(up.stack_prev)\n if down:\n  owned_cells.add(down)\n  down = cells.get(down.stack_next)", []]
[141, "class ClientSock(REQ):", [["^\\t", 145], ["#", 165]]]
[143, "def __init__(self,client):", [["^\\t", 144]]]
[144, "self.client = client\nself.manager = client.manager\nsocket_path = os.path.join(client.socket_dir,\"client.gradesock\")\nsuper().__init__(socket_path,gradesta_pb2.ClientState)", []]
[145, "#methods", [["", 143], ["", 147], ["#", 194], ["", 259]]]
[146, "class ServiceSock(REQ):", [["^\\t", 149], ["#", 165]]]
[147, "def process(self,message):", [["^\\t", 148]]]
[148, "self.client.process(message)", []]
[149, "#methods", [["", 150], ["", 152]]]
[150, "def __init__(self,manager,service,socket):", [["^\\t", 151]]]
[151, "self.manager = manager\nself.service = service\nsuper().__init__(socket,gradesta_pb2.ServiceState)\ninit_message = gradesta_pb2.ServiceState()\nself.send(init_message)\nself.process(self.recv())", []]
[152, "def process(self,message):", [["^\\t", 153]]]
[153, "self.service.process(message)", []]
[154, "class ServiceManagerSock(REP):", [["^\\t", 155], ["#", 196]]]
[155, "# methods", [["", 156], ["", 218]]]
[156, "def __init__(self,manager,service):", [["^\\t", 157]]]
[157, "self.manager = manager\nself.service = service\nsuper().__init__(\"manager.gradesock\",gradesta_pb2.ServiceState)", []]
[165, "class REQ(ProtobufSocket):", [["^\\t", 166], ["#", 176]]]
[166, "#methods", [["", 167]]]
[167, "def __init__(self,socket,msg_type):", [["^\\t", 168]]]
[168, "super().__init__(msg_type)\nself.socket = zmq_context.socket(zmq.REQ)\nself.socket_path = \"ipc://\"+os.path.join(os.getcwd(),socket)\nself.socket.connect(self.socket_path)", []]
[169, "class PUB(ProtobufSocket):", [["^\\t", 170], ["#", 176]]]
[170, "#methods", [["", 172]]]
[172, "def __init__(self,socket,msg_type):", [["^\\t", 173]]]
[173, "super().__init__(msg_type)\nself.socket = zmq_context.socket(zmq.PUB)\nself.socket_path = \"ipc://\"+os.path.join(os.getcwd(),socket)\nself.socket.connect(self.socket_path)", []]
[174, "def send(self,message):", [["^\\t", 175]]]
[175, "self.socket.send(message.SerializeToString())", []]
[176, "class ProtobufSocket():", [["^\\t", 177]]]
[177, "#methods", [["", 180], ["", 174], ["", 178], ["", 278]]]
[178, "def recv(self):", [["^\\t", 179]]]
[179, "m = self.msg_type()\nm.ParseFromString(self.socket.recv())\nreturn m", []]
[180, "def __init__(self,msg_type):", [["^\\t", 181]]]
[181, "self.msg_type = msg_type", []]
[183, "def loop(self):", [["^\\t", 212]]]
[185, "process_req_from_service\nself.logger.log(\"Waiting for a message on manager.gradesock.\")\nmessage = self.recv();\nself.logger.log(\"Received message on manager.gradesock\")\nself.service.process(message.service_state)", []]
[186, "make_manager_object_and_loop service_pid\nmanager = Manager(service_pid)\nmanager.loop()", []]
[187, "class Cursors():", [["^\\t", 188]]]
[188, "#methods", [["", 189], ["", 190], ["", 191], ["", 192]]]
[189, "def __init__(self,cells):", []]
[190, "def add_cursor(self, client_id, cursor):", []]
[191, "def calculate_ownership(self):", []]
[192, "def get_cells_owned_by(self,client_id):", []]
[194, "def get_owned_cells(self,cells):", []]
[195, "#globals\nzmq_context = zmq.Context()", []]
[196, "class REP(ProtobufSocket):", [["^\\t", 197], ["#", 176]]]
[197, "#methods", [["", 198]]]
[198, "def __init__(self,socket,msg_type):", [["^\\t", 199]]]
[199, "super().__init__(msg_type)\nself.socket = zmq_context.socket(zmq.REP)\nself.socket.bind(\"ipc://\"+os.path.join(os.getcwd(),socket))", []]
[200, "class Logger():", [["^\\t", 201]]]
[201, "#methods", [["", 202], ["", 204]]]
[202, "def __init__(self):", [["^\\t", 203]]]
[203, "pass", []]
[204, "def log(self,m):", [["^\\t", 205]]]
[205, "print(m)", []]
[206, "take_client | message\nclient = next(client_iter)", [["client.status == gradesta_pb2.ClientState.INITIALIZING; client_iter | client", 208], ["client.status == gradesta_pb2.Client.DISCONNECTING; client_iter | client", 210], ["; client_iter | client", 209]]]
[207, "pass_on_message client_origins message |\nif client_origins:\n self.logger.log(\"Forwarding message to service to see what service has to say.\")\n self.service.send(message.service_state)\n rep = self.service.recv()\n self.socket.send(rep.SerializeToString())\nelse:\n rep = gradesta_pb2.ClientState()\n self.logger.log(\"Sending empty response to service.\")\n self.socket.send(rep.SerializeToString())\nfor client_id,client in self.clients.items():\n if not client_id in client_origins:\n  self.logger.log(\"Forwarding message to client %s.\"%client_id)\n  client.send(message)", [[";", 185]]]
[208, "add_new_clients client\nif client.client_id in self.clients:\n self.logger.log(\"Error, cannot initialize client twice.\\n%s\",str(client))\nelse:\n self.logger.log(\"Adding new client %s with human readable name '%s'.\"%(client.client_id,client.name))\n self.clients[client.client_id] = Client(os.path.join(client.client_id,\"client.gradesock\"),client)", [[";client", 209]]]
[209, "add_client_origin client_origins | client\nclient_origins.add(client.client_id)", [["; client_origins | client", 211]]]
[210, "disconnect_client client\nprint(\"Client %s is disconnecting.\"%(client.client_id))\ntry:\n del self.clients[client.client_id]\nexcept KeyError:\n pass", [[";", 207]]]
[211, "process_client_state client\nself.clients[client.client_id].process(client)", [[";", 207]]]
[212, "", [["!^pycfg -f", 214]]]
[214, "select(service_manager,client_manager,client_initialization_watchdog)", [["", 185], ["", 215], ["", 216]]]
[215, "process_req_from_client", []]
[216, "initialize_new_client", []]
[217, "class ClientManagerSock(REP):", [["^\\t", 220], ["#", 196]]]
[218, "def process(self,m):", [["^\\t", 219]]]
[219, "", [["!^pycfg -f", 206]]]
[220, "#methods", [["", 221], ["", 267]]]
[221, "def __init__(self,client):", [["^\\t", 222]]]
[222, "self.client = client\nsuper().__init__(os.path.join(self.client.socket_dir,\"manager.gradesock\"),gradesta_pb2.ClientState)", []]
[223, "class Manager():", [["^\\t", 224], ["#", 237], ["#", 269], ["#", 248], ["#", 200]]]
[224, "#methods", [["", 225], ["", 227], ["", 280]]]
[225, "def __init__(self,service_pid):", [["^\\t", 226]]]
[226, "self.service = Service(self,service_pid)\ntry:\n os.mkdir(\"clients\")\nexcept FileExistsError:\n pass\nself.client_connection_watchdog = ClientConnectionWatchdog()\nself.clients = {}\nself.logger = Logger()", []]
[227, "def loop(self):", [["^\\t", 228]]]
[228, "", [["!^pycfg -f", 229]]]
[229, "wait_for_event\nself.logger.log(\"Waiting\")\n(r,w,x) = zmq.select([self.service.service_manager_sock.socket,self.client_connection_watchdog]+[x.manager_socket.socket for x in self.clients.values()],[],[])\nself.logger.log(\"Events recieved. Read: %s Write: %s Errors: %s\"%(r,w,x))\nfnos = r+w+x\nfnosi = iter(fnos)", [[";fnosi|", 233]]]
[233, "read_sockets fnosi |\nfno = next(fnosi)", [["fno == self.service.service_manager_sock.socket;fnosi |", 234], ["fno == self.client_connection_watchdog.fileno(); fnosi|", 235], ["; fnosi | fno", 236], ["end;", 229]]]
[234, "service_manager_req\nself.service_manager.process(self.service_manager.recv())", [[";", 233]]]
[235, "process_client_connect_disconnect\nself.client_connection_watchdog.clear()\ndirs = os.listdir(\"clients\")\ndirs = [dir for dir in dirs if dir not in (\"..\",\".\")]\nclients_with_socks = []\ncleaned_up_now = set()\nfor dir in dirs:\n sock = os.path.join(\"clients\",dir,\"client.gradesock\")\n if os.path.exists(sock):\n  clients_with_socks.append(dir)\n elif not os.path.exists(os.path.join(\"clients\",dir,\"manager.gradesock\")):\n  os.rmdir(os.path.join(\"clients\",dir))\n  cleaned_up_now.add(dir)\nif not set(dirs) - cleaned_up_now:\n self.shutdown()\n#process disconnections\nclients_to_disconnect = [client_id for client_id in self.clients.keys() if client_id not in clients_with_socks]\nself.logger.log(\"Clients to disconnect: \"+str(clients_to_disconnect))\nfor client_id in clients_to_disconnect:\n self.clients[client_id].disconnect()\n del self.clients[client_id]\n#process connections\nclients_to_connect = [client_id for client_id in clients_with_socks if client_id not in self.clients]\nfor client_id in clients_to_connect:\n client = Client(self,client_id)\n self.logger.log(client_id)\n self.clients[client_id] = client\n client.init_manager_socket()\n client.connect_client_socket()\nself.logger.log(\"Currently connected clients:\")\nfor client_id,client in self.clients.items():\n self.logger.log(client_id + \": \"+client.name)", [[";", 233]]]
[236, "process_client_req fno\nfor client_id,client in self.clients.items():\n if client.socket == fno:\n  client.process(client.recv())\n  break", [[";", 233]]]
[237, "class Client():", [["^\\t", 238], ["^\\t", 240], ["#", 141], ["#", 217]]]
[238, "#methods", [["", 239], ["", 243], ["", 245], ["", 266], ["", 276]]]
[239, "def __init__(self, manager, client_id):", [["^\\t", 242]]]
[240, "#properties", [["", 241]]]
[241, "#socket_dir\n@property\ndef socket_dir(self):\n return os.path.join(\"clients\",self.client_id)", []]
[242, "self.client_id = client_id\nself.name = \"\"\nself.source_url = \"\"\n\nself.manager_socket = None\nself.client_socket = None\nself.manager = manager", []]
[243, "def init_manager_socket(self):", [["^\\t", 244]]]
[244, "self.manager_socket = ClientManagerSock(self)", []]
[245, "def connect_client_socket(self):", [["^\\t", 246]]]
[246, "self.client_socket = ClientSock(self)\nself.client_socket.send_init_message()", []]
[248, "class ClientConnectionWatchdog():", [["^\\t", 249]]]
[249, "#methods", [["", 250], ["", 252], ["", 253]]]
[250, "def __init__(self):", [["^\\t", 251]]]
[251, "self.proc = subprocess.Popen([\"inotifywait\",\"--monitor\",\"--recursive\",\"--event\",\"create\",\"--event\",\"delete\",\"clients\"],stdout=subprocess.PIPE)\n# http://eyalarubas.com/python-subproc-nonblock.html\nflags = fcntl.fcntl(self.proc.stdout, fcntl.F_GETFL)\nfcntl.fcntl(self.proc.stdout, fcntl.F_SETFL, flags | os.O_NONBLOCK)", []]
[252, "def fileno(self):", [["^\\t", 254]]]
[253, "def clear(self):", [["^\\t", 255]]]
[254, "return self.proc.stdout.fileno()", []]
[255, "print(\"READ:\"+self.proc.stdout.read().decode(\"utf-8\"))", []]
[259, "def send_init_message(self):", [["^\\t", 260]]]
[260, "m = gradesta_pb2.ClientState()\n#m.service_state.bookmarks.update(self.client.manager.service.bookmarks)\nm.service_state.name = self.manager.service.name\nm.service_state.source_url = self.manager.service.source_url\nfor name,bookmark in self.manager.service.bookmarks.items():\n b = m.service_state.bookmarks[name]\n b.CopyFrom(bookmark)\n\nself.send(m)\nself.recv()\nself.manager.logger.log(\"Sent init message to client %s. Via socket %s\"%(self.client.client_id,self.socket_path))", []]
[261, "#ZMQ/Protobuf helpers", [["", 176], ["", 165], ["", 196], ["", 169], ["", 262]]]
[262, "class ROUTER(ProtobufSocket):", [["^\\t", 263], ["#", 176]]]
[263, "#methods", [["", 264]]]
[264, "def __init__(self,socket,msg_type):", [["^\\t", 265]]]
[265, "super().__init__(msg_type)\nself.socket = zmq_context.socket(zmq.ROUTER)\nself.socket_path = \"ipc://\"+os.path.join(os.getcwd(),socket)\nself.socket.connect(self.socket_path)", []]
[266, "def disconnect(self):", [["^\\t", 275]]]
[267, "def disconnect(self):", [["^\\t", 268]]]
[268, "self.socket.close()", []]
[269, "class Service():", [["^\\t", 270], ["#", 154], ["#", 146]]]
[270, "#methods", [["", 271], ["", 273], ["", 282]]]
[271, "def __init__(self,manager,pid):", [["^\\t", 272]]]
[272, "self.manager = manager\nself.pid = pid\nself.name = \"\"\nself.soruce_url = \"\"\nself.bookmarks = {}\nself.cells = {}\nself.saved = True\nself.service_manager_sock = ServiceManagerSock(manager,self)\nself.service_sock = ServiceSock(manager,self,\"service.gradesock\")", []]
[273, "def process(self,message):", [["^\\t", 274]]]
[274, "self.name = message.name\nself.source_url = message.source_url\nself.bookmarks = message.bookmarks\nself.cells.update(message.cells)\nself.saved = message.saved\nfor name,bookmark in self.bookmarks.items():\n print(name+\": \"+bookmark.cell_id)", []]
[275, "self.manager_socket.close()", []]
[276, "def process(self,message):", [["^\\t", 277]]]
[277, "self.name = message.name if message.name else self.name\nself.source_url = message.source_url if message.source_url else self.source_url", []]
[278, "def close(self):", [["^\\t", 279]]]
[279, "self.socket.close()", []]
[280, "def shutdown(self):", [["^\\t", 281]]]
[281, "self.service.shutdown()\nsys.exit()", []]
[282, "def shutdown(self):", [["^\\t", 283]]]
[283, "posix.kill(self.pid, 15) #send TERM to service", []]
