[0, "#!/usr/bin/python3\n# The gradesta-manager is the universal middle man of the gradesta protocol.\n# It tracks gradesta clients and which cells they are subscribed to.", [["^#", 1], ["", 2], ["", 49], ["", 78], ["^#", 57], ["!^pycfg", 4]]]
[1, "License: AGPL >= 3\nCopyright (c) 2017 Timothy Hobbs\n\nThis file is part of Gradesta.\n\nGradesta is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as\npublished by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program. If not, see <http://www.gnu.org/licenses/>.", []]
[2, "#imports\nimport sys\nimport argparse\nimport os\nimport zmq\nimport gradesta_pb2", []]
[4, "parse_cli_args\nparser = argparse.ArgumentParser(description=\"\"\"gradesta-manager the universal middle man of the gradesta protocol.\"\"\",formatter_class=argparse.RawTextHelpFormatter)\nargs = parser.parse_args()", [["; args|", 32]]]
[31, "recv sock |\nprint(\"Waiting for request from client.\")\nm = sock.recv()\nprint(\"Request received.\")\nrqm = gradesta_pb2.RequestToManager()\nrqm.ParseFromString(m)\nrpm = gradesta_pb2.ReplyFromManager()\nrqs = gradesta_pb2.RequestToService()", [["; sock rpm rqs | rqm", 42]]]
[32, "bind_sockets args |\nzmq_context = zmq.Context()\nsock = zmq_context.socket(zmq.REP)\npath = \"ipc://\"+os.path.join(os.getcwd(),\"manager.gradesock\")\nprint(path)\nsock.bind(path)\nservice_sock = zmq_context.socket(zmq.REQ)\nservice_sock.connect(\"ipc://\"+os.path.join(os.getcwd(),\"service.gradesock\"))", [["; sock service_sock args zmq_context |", 38]]]
[34, "next_req_id i |\nrid = next(i)", [["; i | rid 0", 35], ["end;", 39]]]
[35, "generate_id clients | rid suffix\nif suffix == 0:\n id = rid.prefix\nelse:\n id = rid.prefix + str(suffix)", [["not id in clients; clients | id", 36], [";clients | rid suffix+1", 35]]]
[36, "add_id clients rpm | id\nidm = gradesta_pb2.ClientId()\nidm.client_id = id\nrpm.assigned_id.extend([idm])\nclients.add(id)", [["; clients rpm |", 34]]]
[37, "send_reply sock rpm |\nprint(\"Sending reply.\")\nsock.send(rpm.SerializeToString())", [["; sock |", 31]]]
[38, "init_states\nclients = set() # set of client ids\nsubscriptions = {} # maps client ids to subscriptions\ncells = {} # maps cell ids to cells\nupdate_socks = {} # maps clients to update socks", [["; clients subscriptions cells update_socks |", 31]]]
[39, "subscribe_commands rqm |\ni = iter(rqm.subscription)", [["; i rqm |", 40]]]
[40, "next_new_subscription i |\nsubscription = next(i)", [["not subscription.neighborhood.center_cell in subscriptions; i | subscription", 45], ["; i | subscription", 41], ["end;", 69]]]
[41, "subscribe_to_neighborhood subscriptions subscription |\nsub_changed = subscriptions[subscription.neighborhood.center_cell].add_subscription(subscription)", [["sub_changed ; subscriptions | subscription", 56], ["; subscriptions | ", 40]]]
[42, "process_id_requests rqm\ni = iter(rqm.request_id)", [["; i rqm |", 34]]]
[45, "init_neighborhood subscriptions | subscription\ncenter_cell = subscription.neighborhood.center_cell\nsubscriptions[center_cell] = Subscriptions(center_cell)", [[";subscriptions subscription |", 41]]]
[49, "#functions", [["", 119], ["", 121]]]
[55, "pass_on_request_to_service service_sock rqs rpm |\nservice_sock.send(rqs.SerializeToString())\nrps = gradesta_pb2.ReplyFromService()\nrps.ParseFromString(service_sock.recv())\nrpm.requested_neighborhood.extend(rps.requested_neighborhood)\nrpm.set_outcome.CopyFrom(rps.set_outcome)", [[";rpm service_sock |", 72]]]
[56, "add_sub_request rqs | updated_sub\nrqs.subscribe.extend([updated_sub])", [[";rqs |", 40]]]
[57, "Initialization steps:\n - Parse args\n - Initialize global state\n - Bind sockets", [["", 59], ["", 4], ["", 32], ["", 38]]]
[59, "Packet receive loop", [["", 60], ["", 31]]]
[60, "Assign client Ids", [["", 61], ["", 42]]]
[61, "Update subscriptions", [["", 64], ["", 39]]]
[62, "If needed, send request to service", [["", 74], ["", 55]]]
[63, "Pass on news of changed cells to OTHER clients for whom it is relevant.", [[" 1", 77], [" 2", 87], [" 3", 88], [" 4", 89]]]
[64, "Process set cell requests", [["", 66], ["", 69]]]
[66, "Process events", [["", 62], ["", 71]]]
[67, "Send reply to client that initialized request.", [["", 73], ["", 37]]]
[69, "set_cells rqs rqm |\n# A no-op. We just pass the command on to the service.\nrqs.set.CopyFrom(rqm.set)", [["; rqs rqm |", 71]]]
[71, "process_events rqs rqm |\n# No-op. Pass command on to service.\nrqs.event.extend(rqm.event)", [["rqs.subscribe or rqs.set or rqs.event; rqs rqm |", 55], [";", 37]]]
[72, "gather_changes rpm rqm |\nchanged_cells = []\nchanged_resources = []\nif rpm.set_outcome.ok:\n  changed_cells.extend(rpm.set_outcome.changes.cells)\n  changed_resources.extend(rpm.set_outcome.changes.resources)\nchanged_cells.extend(rqm.set_service_side.cells)\nchanged_resources.extend(rqm.set_service_side.resources)", [["; rpm rqm changed_cells |", 75]]]
[73, "Update internal cell cache", [["", 63], ["", 75]]]
[74, "Gather changes to cells and resources", [["", 67], ["", 72]]]
[75, "update_cell_cache cells changed_cells |\nfor cell in changed_cells:\n  cells[cell.id] = cell", [["; cells |", 37], ["False ; cells changed_cells |", 111]]]
[77, "Build cell ownership database", [["", 109], ["", 99]]]
[78, "#classes", [["", 79]]]
[79, "class Subscriptions():", [["^\\t", 80], ["^\\t", 81]]]
[80, "# methods", [["", 82], ["", 102], ["", 84], ["", 100], ["", 104], ["", 107]]]
[81, "# properties", []]
[82, "def __init__(self,center_cell):", [["^\\t", 83]]]
[83, "self._subscriptions = {}\nself.center_cell = center_cell\nself.prev_max = gradesta_pb2.Neighborhood()\nself.n = gradesta_pb2.Neighborhood()", []]
[84, "def _add_subscription(self, subscription):", [["^\\t", 85]]]
[85, "sn = subscription.neighborhood\nn  = self.n\nn.directions = n.directions | sn.directions\nn.max_distance = max(n.max_distance, sn.max_distance)\nn.center_stack = max(n.center_stack, sn.center_stack)\nn.total_max_size = max(n.total_max_size,sn.total_max_size)", []]
[87, "For each set cell/resouce, look up owners in ownership database.", [["", 97]]]
[88, "Add cell/resource to dictionary which maps clients to a set of cells/resources which have changed.", [["", 97]]]
[89, "For each client in dictionary send set of cells/resources which have changed to update.sock", [["", 98]]]
[97, "look_up_owners changed_cells changed_resources ownership_database\ndef build_notification_dict(changes, get_id):\n notification_dict = {}\n for thing in changes:\n  if get_id(thing) in ownership_database:\n   for client in ownership_database[get_id(thing)]:\n    if client not in notification_dict:\n     notification_dict[client] = set()\n    notification_dict[client].add(thing)\n# cell change client notification dict\n# maps clients to sets of changed cells.\nccd = build_notification_dict(changed_cells, lambda cell: cell.id)\n# resource change client notification dict\ncrd = build_notification_dict(changed_resources, lambda resource: resource.cell_id)", [["; ccd crd ", 98]]]
[98, "send_updates_to_clients update_socks rqm zmq_context | ccd crd\n#ccd: Client to (changed) cell dict\n#crd: Client to (changed) resource dict\n# all clients to be notified\nactbn = set()\nactbn.add(ccd.keys())\nctbn.add(crd.keys())\nfor client in actbn:\n if not client in rqm:\n  if client not in update_socks:\n   #try:\n    update_socks[client] = zmq_context.socket(zmq.PUB)\n    update_socks[client].bind(\"ipc://\"+os.path.join(os.getcwd(),\"clients\",client,\"update.gradesock\"))\n   #except :\n   # pass\n  if client in update_socks:\n   setb = gradesta_pb2.Set()\n   setb.cells = list(ccd[client])\n   setb.resources = list(crd[client])\n   update_socks[client].send(setb.SerializeToString())", [[";update_socks zmq_context |", 31]]]
[99, "For each MaxNeighborhood, start walking in each of the four directions", [["", 112]]]
[100, "def remove_subscription(self, subscription):", [["^\\t", 101]]]
[101, "self._start()\nn = self.n\nn.max_distance = 0\nn.directions = 0\nn.center_stack = 0\nn.total_max_size = 0\nfor subscription in self._subscriptions.values():\n self._add_subscripion(subscription)\nreturn self._changed()", []]
[102, "def add_subscription(self, subscription):", [["^\\t", 103]]]
[103, "self._start()\nself.subscriptions[subscription.n.cient_id] = subscription\nself._add_subscription(subscription)\nreturn self._changed()", []]
[104, "def _start(self):", [["^\\t", 105]]]
[105, "n = self.n\nself.prev_max.max_distance = n.max_distance\nself.prev_max.directions = n.directions\nself.prev_max.center_stack = n.center_stack\nself.prev_max.total_max_size = n.total_max_size", []]
[107, "def _changed(self):", [["^\\t", 108]]]
[108, "n = self.n\npm = self.prev_max\nreturn not (pm.max_distance == n.max_distance and pm.directions == n.directions and pm.center_stack == n.center_stack and pm.total_max_size == n.total_max_size)", []]
[109, "Initialize database", [["", 111]]]
[111, "init_ownership_database\nownership_database = {} # maps cells to clients", [[";", 112]]]
[112, "loop_over_subscriptions subscriptions |\nsi = iter(subscriptions)", [["; si", 114]]]
[114, "next_subscription si\nsubscription = next(si)", [["; subscription", 116], ["end;", 97]]]
[116, "initialize_four_directions subscription\nedge = []\n", []]
[119, "def walk_edge_of_neighborhood(cells, subscription):", [["^\\t", 120]]]
[120, "NORTH  = 0b0001\nEAST   = 0b0010\nSOUTH  = 0b0100\nWEST   = 0b1000\n\nALL_DIRECTIONS = 0b1111\nALL_BUT_NORTH  = NORTH | ALL_DIRECTIONS\nALL_BUT_EAST   = EAST  | ALL_DIRECTIONS\nALL_BUT_SOUTH  = SOUTH | ALL_DIRECTIONS\nALL_BUT_WEST   = WEST  | ALL_DIRECTIONS\n\nnew_edge = []\ndef take_one_step(new_center, new_directions):\n further_out = copy.deep_copy(subscription)\n further_out.neighborhood = new_center\n further_out.max_distance -= 1\n further_out.directions = new_directions\n new_edge.append(futher_out)\n\ndef is_local(edge):\n return edge.protocol == '.' and edge.path == '.'\n\ncenter = cells[subscription.neighborhood.center_cell]\nif subscription.max_distance > 0:\n if subscription.directions & NORTH:\n  take_one_step(center.stack_prev, ALL_BUT_NORTH)\n if subscription.directions & EAST and is_local(center.eastedge):\n  take_one_step(center.eastedge.client_id, ALL_BUT_EAST)\n if subscription.directions & SOUTH:\n  take_one_step(center.stack_next, ALL_BUT_SOUTH)\n if subscripiton.directions & WEST and is_local(center.westedge):\n  take_one_step(center.westedge.client_id, ALL_BUT_WEST)\n\nreturn new_edge", []]
[121, "def walk_up_and_down_stack(cells, subscription):", [["^\\t", 122]]]
[122, "owned_cells  = set()\nstack_height = subscription.neighborhood.center_stack\ncenter_cell  = cells[subscription.neighborhood.center_cell]\nup   = cells.get(center_cell.stack_prev)\ndown = cells.get(center_cell.stack_next)\nwhile stack_height and (up or down):\n stack_height -= 1\n if up:\n  owned_cells.add(up)\n  up   = cells.get(up.stack_prev)\n if down:\n  owned_cells.add(down)\n  down = cells.get(down.stack_next)", []]
