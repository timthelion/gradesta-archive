[0, "#!/usr/bin/python3\n# The gradesta-manager is the universal middle man of the gradesta protocol.\n# It tracks gradesta clients and which cells they are subscribed to.", [["^#", 1], ["", 2], ["", 195], ["", 49], ["", 78], ["!^pycfg", 4]]]
[1, "License: AGPL >= 3\nCopyright (c) 2017 Timothy Hobbs\n\nThis file is part of Gradesta.\n\nGradesta is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as\npublished by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program. If not, see <http://www.gnu.org/licenses/>.", []]
[2, "#imports\nimport sys\nimport argparse\nimport os\nimport zmq\nimport gradesta_pb2", []]
[4, "parse_cli_args\nparser = argparse.ArgumentParser(description=\"\"\"gradesta-manager the universal middle man of the gradesta protocol.\"\"\",formatter_class=argparse.RawTextHelpFormatter)\nargs = parser.parse_args()", [[";args|", 186]]]
[141, "class Client(PUB):", [["^\\t", 145]]]
[143, "def __init__(self,socket,message):", [["^\\t", 144]]]
[144, "super().__init__(socket,gradesta_pb2.ClientState)\nself.process(message)", []]
[145, "#methods", [["", 143], ["", 147], ["#", 194]]]
[146, "class Service(REQ):", [["^\\t", 149]]]
[147, "def process(self,message):", [["^\\t", 148]]]
[148, "self.client_id = message.client_id\nself.message_count = message.message_count\nself.cursors = message.cursors", []]
[149, "#methods", [["", 150], ["", 152]]]
[150, "def __init__(self,socket):", [["^\\t", 151]]]
[151, "super().__init__(socket,gradesta_pb2.ServiceState)", []]
[152, "def process(self,message):", [["^\\t", 153]]]
[153, "self.service_name = message.service_name\nself.bookmarks = message.bookmarks\nself.cells = message.cells\nself.saved = message.saved\nfor bookmark in self.bookmarks:\n print(bookmark.name+\": \"+bookmark.cell_id)", []]
[154, "class Manager(REP):", [["^\\t", 155]]]
[155, "# methods", [["", 156], ["", 183]]]
[156, "def __init__(self):", [["^\\t", 157]]]
[157, "super().__init__(\"manager.gradesock\",gradesta_pb2.ClientState)\nself.service = Service(\"service.gradesock\")\ninit_message = gradesta_pb2.ServiceState()\nself.service.send(init_message)\nself.service.process(self.service.recv())\nself.clients = {}\nself.logger = Logger()", []]
[209, "add_client_origin client_origins | client\nclient_origins.add(client.client_id)", [["; client_origins | client", 211]]]
[165, "class REQ(ProtobufSocket):", [["^\\t", 166]]]
[166, "#methods", [["", 167]]]
[167, "def __init__(self,socket,msg_type):", [["^\\t", 168]]]
[168, "super().__init__(msg_type)\nself.socket = zmq_context.socket(zmq.REQ)\nself.socket.connect(\"ipc://\"+os.path.join(os.getcwd(),socket))", []]
[169, "class PUB(ProtobufSocket):", [["^\\t", 170]]]
[170, "#methods", [["", 172]]]
[172, "def __init__(self,socket,msg_type):", [["^\\t", 173]]]
[173, "super().__init__(msg_type)\nself.socket = zmq_context.socket(zmq.PUB)\nself.socket.connect(\"ipc://\"+os.path.join(os.getcwd(),socket))", []]
[174, "def send(self,message):", [["^\\t", 175]]]
[175, "self.socket.send(message.SerializeToString())", []]
[176, "class ProtobufSocket():", [["^\\t", 177]]]
[49, "#functions", [["", 119], ["", 121]]]
[177, "#methods", [["", 180], ["", 174], ["", 178]]]
[178, "def recv(self):", [["^\\t", 179]]]
[180, "def __init__(self,msg_type):", [["^\\t", 181]]]
[181, "self.msg_type = msg_type", []]
[179, "m = self.msg_type()\nm.ParseFromString(self.socket.recv())\nreturn m", []]
[183, "def loop(self):", [["^\\t", 212]]]
[185, "recv_message\nself.logger.log(\"Waiting for a message on manager.gradesock.\")\nmessage = self.recv();\nself.logger.log(\"Received message on manager.gradesock\")\nclient_origins = set() # Where did the message come from?\nself.service.process(message.service_state)\nclient_iter = iter(message.clients)", [["; client_iter client_origins message |", 206]]]
[186, "make_manager_object_and_loop\nmanager = Manager()\nmanager.loop()", []]
[187, "class Cursors():", [["^\\t", 188]]]
[188, "#methods", [["", 189], ["", 190], ["", 191], ["", 192]]]
[189, "def __init__(self,cells):", []]
[190, "def add_cursor(self, client_id, cursor):", []]
[191, "def calculate_ownership(self):", []]
[192, "def get_cells_owned_by(self,client_id):", []]
[194, "def get_owned_cells(self,cells):", []]
[195, "#globals\nzmq_context = zmq.Context()", []]
[196, "class REP(ProtobufSocket):", [["^\\t", 197]]]
[197, "#methods", [["", 198]]]
[198, "def __init__(self,socket,msg_type):", [["^\\t", 199]]]
[199, "super().__init__(msg_type)\nself.socket = zmq_context.socket(zmq.REP)\nself.socket.bind(\"ipc://\"+os.path.join(os.getcwd(),socket))", []]
[200, "class Logger():", [["^\\t", 201]]]
[201, "#methods", [["", 202], ["", 204]]]
[202, "def __init__(self):", [["^\\t", 203]]]
[203, "pass", []]
[204, "def log(self,m):", [["^\\t", 205]]]
[205, "print(m)", []]
[78, "#classes", [["", 79], ["#", 187], ["", 176], ["", 165], ["", 169], ["", 196], ["", 141], ["", 146], ["", 154], ["", 200]]]
[79, "class Subscriptions():", [["^\\t", 80], ["^\\t", 81]]]
[80, "# methods", [["", 82], ["", 102], ["", 84], ["", 100], ["", 104], ["", 107]]]
[81, "# properties", []]
[82, "def __init__(self,center_cell):", [["^\\t", 83]]]
[83, "self._subscriptions = {}\nself.center_cell = center_cell\nself.prev_max = gradesta_pb2.Neighborhood()\nself.n = gradesta_pb2.Neighborhood()", []]
[84, "def _add_subscription(self, subscription):", [["^\\t", 85]]]
[85, "sn = subscription.neighborhood\nn  = self.n\nn.directions = n.directions | sn.directions\nn.max_distance = max(n.max_distance, sn.max_distance)\nn.center_stack = max(n.center_stack, sn.center_stack)\nn.total_max_size = max(n.total_max_size,sn.total_max_size)", []]
[212, "", [["!^pycfg -f", 185]]]
[206, "next_client client_iter |\nclient = next(client_iter)", [["end;", 207], ["client.client_status == gradesta_pb2.ClientState.INITIALIZING; client_iter | client", 208], ["client.client_status == gradesta_pb2.Client.DISCONNECTING; client_iter | client", 210], ["client.message_count > self.clients[client.client_id].message_count; client_iter | client", 209], ["; client_iter | client", 211]]]
[207, "pass_on_message client_origins message |\nif client_origins:\n self.logger.log(\"Forwarding message to service to see what service has to say.\")\n self.service.send(message.service_state)\n rep = self.service.recv()\n self.socket.send(rep.SerializeToString())\nelse:\n rep = gradesta_pb2.ClientState()\n self.logger.log(\"Sending empty response to service.\")\n self.socket.send(rep.SerializeToString())\nfor client_id,client in self.clients.items():\n if not client_id in client_origins:\n  self.logger.log(\"Forwarding message to client %s.\"%client_id)\n  client.send(message)", [[";", 185]]]
[208, "add_new_clients client\nif client.client_id in self.clients:\n self.logger.log(\"Error, cannot initialize client twice.\\n%s\",str(client))\nelse:\n self.logger.log(\"Adding new client %s with human readable name '%s'.\"%(client.client_id,client.name))\n self.clients[client.client_id] = Client(os.path.join(client.client_id,\"client.gradesock\"),client)", [[";client", 209]]]
[210, "disconnect_client client\nprint(\"Client %s is disconnecting.\"%(client.client_id))\ntry:\n del self.clients[client.client_id]\nexcept KeyError:\n pass", [[";", 206]]]
[211, "process_client_state client\nself.clients[client.client_id].process(client)", [[";", 206]]]
[100, "def remove_subscription(self, subscription):", [["^\\t", 101]]]
[101, "self._start()\nn = self.n\nn.max_distance = 0\nn.directions = 0\nn.center_stack = 0\nn.total_max_size = 0\nfor subscription in self._subscriptions.values():\n self._add_subscripion(subscription)\nreturn self._changed()", []]
[102, "def add_cursor(self, cursor):", [["^\\t", 103]]]
[103, "self._start()\nself.subscriptions[subscription.n.cient_id] = subscription\nself._add_subscription(subscription)\nreturn self._changed()", []]
[104, "def _start(self):", [["^\\t", 105]]]
[105, "n = self.n\nself.prev_max.max_distance = n.max_distance\nself.prev_max.directions = n.directions\nself.prev_max.center_stack = n.center_stack\nself.prev_max.total_max_size = n.total_max_size", []]
[107, "def _changed(self):", [["^\\t", 108]]]
[108, "n = self.n\npm = self.prev_max\nreturn not (pm.max_distance == n.max_distance and pm.directions == n.directions and pm.center_stack == n.center_stack and pm.total_max_size == n.total_max_size)", []]
[119, "def walk_edge_of_neighborhood(cells, subscription):", [["^\\t", 120]]]
[120, "NORTH  = 0b0001\nEAST   = 0b0010\nSOUTH  = 0b0100\nWEST   = 0b1000\n\nALL_DIRECTIONS = 0b1111\nALL_BUT_NORTH  = NORTH | ALL_DIRECTIONS\nALL_BUT_EAST   = EAST  | ALL_DIRECTIONS\nALL_BUT_SOUTH  = SOUTH | ALL_DIRECTIONS\nALL_BUT_WEST   = WEST  | ALL_DIRECTIONS\n\nnew_edge = []\ndef take_one_step(new_center, new_directions):\n further_out = copy.deep_copy(subscription)\n further_out.neighborhood = new_center\n further_out.max_distance -= 1\n further_out.directions = new_directions\n new_edge.append(futher_out)\n\ndef is_local(edge):\n return edge.protocol == '.' and edge.path == '.'\n\ncenter = cells[subscription.neighborhood.center_cell]\nif subscription.max_distance > 0:\n if subscription.directions & NORTH:\n  take_one_step(center.stack_prev, ALL_BUT_NORTH)\n if subscription.directions & EAST and is_local(center.eastedge):\n  take_one_step(center.eastedge.client_id, ALL_BUT_EAST)\n if subscription.directions & SOUTH:\n  take_one_step(center.stack_next, ALL_BUT_SOUTH)\n if subscripiton.directions & WEST and is_local(center.westedge):\n  take_one_step(center.westedge.client_id, ALL_BUT_WEST)\n\nreturn new_edge", []]
[121, "def walk_up_and_down_stack(cells, subscription):", [["^\\t", 122]]]
[122, "owned_cells  = set()\nstack_height = subscription.neighborhood.center_stack\ncenter_cell  = cells[subscription.neighborhood.center_cell]\nup   = cells.get(center_cell.stack_prev)\ndown = cells.get(center_cell.stack_next)\nwhile stack_height and (up or down):\n stack_height -= 1\n if up:\n  owned_cells.add(up)\n  up   = cells.get(up.stack_prev)\n if down:\n  owned_cells.add(down)\n  down = cells.get(down.stack_next)", []]
